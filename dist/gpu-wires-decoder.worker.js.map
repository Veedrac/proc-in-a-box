{"version":3,"file":"gpu-wires-decoder.worker.js","sources":["../src/utils/setZeroTimeout.js","../src/backends/gpu-wires-decoder.worker.js"],"sourcesContent":["// From https://dbaron.org/log/20100309-faster-timeouts\n\nconst timeouts = [];\nconst messageName = \"zero-timeout-message\";\n\n// Like setTimeout, but only takes a function argument.  There's\n// no time argument (always zero) and no arguments (you have to\n// use a closure).\nexport const setZeroTimeout = function(fn) {\n    timeouts.push(fn);\n    window.postMessage(messageName, \"*\");\n}\n\nconst handleMessage = function(event) {\n    if (event.source === window && event.data === messageName) {\n        event.stopPropagation();\n        if (timeouts.length > 0) {\n            let fn = timeouts.shift();\n            fn();\n        }\n    }\n}\n\nwindow.addEventListener(\"message\", handleMessage, true);\n\nexport const pause = function() {\n    return new Promise(resolve => setZeroTimeout(resolve));\n}\n","// TODO\n\nimport { pause } from '../utils/setZeroTimeout';\n\nconst getKind = function(data, idx) {\n    const r = data[idx + 0];\n    const g = data[idx + 1];\n    const b = data[idx + 2];\n    const rgb = (r << 16) | (g << 8) | (b << 0);\n\n    // LineLogic 2 includes protection and\n    // goals. Protection and wires are orthogonal,\n    // whereas a goal is *always* accompanied\n    // by a protected wire.\n    //\n    // Goals do not seem worth the implementation\n    // effort; avoiding any cost to the GPU\n    // iteration is likely to be non-trivial.\n    // Protection is easy, but I'm unconvinced\n    // that it's worthwhile, and it would be\n    // deprecated by a higher-level UI anyway.\n\n    // no signal (wire, goal, protected wire)\n    if ((rgb === 0x0080FF) || rgb === 0x800000 || rgb === 0x00FFFF) {\n        return 0b01;\n    }\n\n    // signal, any direction (wire or goal, protected wire)\n    if ((rgb & 0xFF7FF0) === 0xFF0000 || (rgb & 0xFFFFF0) === 0xFFFF00) {\n        return 0b11;\n    }\n\n    // no wire, anything else\n    return 0b00;\n}\n\nconst imageToGpuRepresentation = async function(data, width, height, numWires) {\n    // Loops aside, trace *only* from ends.\n    // No stack is needed for this, since it's always a\n    // single one-way traversal.\n    //\n    // When doing so,\n    //\n    //   * OR all the signals together and\n    //     push to the wire states array.\n    //\n    //   * Record all input T-junctions to the line,\n    //     and push each pair to the transition map.\n    //\n    //   * Map the values in the pixels to the\n    //     wire states array location.\n    //\n    // Finally, check for unhandled pixels, aka. loops.\n    //\n    // Afterwards, use the mapping to remap the\n    // transition map to the correct location in the\n    // wire states array, and turn it into an indexed\n    // mapping.\n\n    const size = width * height;\n    numWires = (numWires + 1024) & ~1023;\n\n    // Is each wire on or off?\n    // The preallocated length is massively pessimistic.\n    // An extra state is reserved at the beginning to dump state into.\n    let wireStatesN = 1;\n    const wireStates = new Uint8Array(numWires);\n\n    // TODO\n    let incomingWiresN = 0;\n    const incomingWires = new Uint32Array(numWires * 2);\n    const incomingWireGroupsOff = new Uint32Array(numWires >> 3);\n    const incomingWireGroupsLen = new Uint8Array(numWires);\n\n    // Which wire does each pixel get its value from?\n    const imageDecoder = new Uint32Array(size);\n\n    // Extra information for wire crossings.\n    // This only stores horizontal wires, because they can change\n    // at most once every four wires.\n    const imageDecoderExtra = new Uint32Array(Math.ceil(size >> 2));\n\n    const traverseFrom = function(data, width, i, j) {\n        const idx = (i + 1) + (j + 1) * (width + 2);\n        const kind  = data[idx];\n        const up    = data[idx - (width + 2)] & 1;\n        const down  = data[idx + (width + 2)] & 1;\n        const left  = data[idx - 1] & 1;\n        const right = data[idx + 1] & 1;\n        const numSiblings = up + down + left + right;\n\n        if (numSiblings === 2 || numSiblings === 4) {\n            // Only start traversals from ends.\n            return;\n        }\n\n        // End #1\n        let wireActive = (kind >> 1) & (numSiblings != 3 ? 1 : 0);\n        imageDecoder[i + j * width] = wireStatesN;\n        if ((wireStatesN & 7) == 0) {\n            incomingWireGroupsOff[wireStatesN >> 3] = incomingWiresN;\n        }\n\n        let [m, n] = [i, j];\n        let [dm, dn] = [0, 0];\n\n        if (numSiblings === 0) {\n            wireStates[wireStatesN] = wireActive;\n            wireStatesN++;\n            return;\n        } else if (numSiblings === 1) {\n            // Go towards the filled pixel\n            if      (up)    { dn = -1; }\n            else if (down)  { dn = +1; }\n            else if (left)  { dm = -1; }\n            else if (right) { dm = +1; }\n            else            { throw 1; }\n        } else {\n            // Go away from the empty pixel\n            if      (!up)    { dn = +1; }\n            else if (!down)  { dn = -1; }\n            else if (!left)  { dm = +1; }\n            else if (!right) { dm = -1; }\n            else             { throw 2; }\n        }\n\n        while (true) {\n            [m, n] = [m + dm, n + dn];\n            const mnIdx = m + n * width;\n\n            const straight = data[(m + dm + 1) + (n + dn + 1) * (width + 2)] & 1;\n            const left     = data[(m - dn + 1) + (n + dm + 1) * (width + 2)] & 1;\n            const right    = data[(m + dn + 1) + (n - dm + 1) * (width + 2)] & 1;\n\n            if (straight) {\n                // The line continues\n                if (left && right) {\n                    // Don't cross the streams!\n                    if (dm != 0) {\n                        imageDecoderExtra[mnIdx >> 2] = wireStatesN;\n                    } else {\n                        imageDecoder[mnIdx] = 0x80000000 | wireStatesN;\n                    }\n                } else if (left) {\n                    incomingWires[incomingWiresN] = mnIdx;\n                    incomingWiresN++;\n                    incomingWireGroupsLen[wireStatesN]++;\n                } else if (right) {\n                    incomingWires[incomingWiresN] = mnIdx;\n                    incomingWiresN++;\n                    incomingWireGroupsLen[wireStatesN]++;\n                } else {\n                    wireActive |= data[(m + 1) + (n + 1) * (width + 2)] >> 1;\n                    imageDecoder[mnIdx] = wireStatesN;\n                }\n            } else if (left === right) {\n                // End here\n                wireActive |= (data[(m + 1) + (n + 1) * (width + 2)] >> 1) & (left ? 0 : 1);\n                imageDecoder[mnIdx] = wireStatesN\n                wireStates[wireStatesN] = wireActive;\n                wireStatesN++;\n                return;\n            } else {\n                wireActive |= data[(m + 1) + (n + 1) * (width + 2)] >> 1;\n                imageDecoder[mnIdx] = wireStatesN\n                if (left) {\n                    [dm, dn] = [-dn, +dm];\n                } else {\n                    [dm, dn] = [+dn, -dm];\n                }\n            }\n        }\n    }\n\n    for (let j = 0; j < height; j++) {\n        for (let i = 0; i < width; i++) {\n            if (!data[(i + 1) + (j + 1) * (width + 2)]) {\n                continue;\n            }\n            if (imageDecoder[i + j * width] != 0) {\n                continue;\n            }\n\n            traverseFrom(data, width, i, j);\n        }\n\n        if (j % 10 == 0) {\n            const fps = document.getElementById(\"fps\");\n            if (fps) { fps.innerHTML = j.toString(); }\n            await pause();\n        }\n    }\n\n    const traverseLoopsFrom = function(data, width, i, j) {\n        const idx = (i + 1) + (j + 1) * (width + 2);\n        const kind  = data[idx];\n        const up    = data[idx - (width + 2)] & 1;\n        const down  = data[idx + (width + 2)] & 1;\n        const left  = data[idx - 1] & 1;\n        const right = data[idx + 1] & 1;\n        const numSiblings = up + down + left + right;\n\n        if (numSiblings !== 2) {\n            // Only loops should be missing!\n            throw 3;\n        }\n\n        // Loop \"start\"; stop when reached again.\n        let wireActive = kind >> 1;\n        imageDecoder[i + j * width] = wireStatesN;\n        if ((wireStatesN & 7) == 0) {\n            incomingWireGroupsOff[wireStatesN >> 3] = incomingWiresN;\n        }\n\n        let [m, n] = [i, j];\n        let [dm, dn] = [0, 0];\n\n        // Any side will do right now.\n        if      (up)   { dn = -1; }\n        else if (down) { dn = +1; }\n        else           { dm = -1; }\n\n        while (true) {\n            [m, n] = [m + dm, n + dn];\n            const mnIdx = m + n * width;\n\n            if (m == i && n == j) {\n                // Back to the future.\n                wireStates[wireStatesN] = wireActive;\n                wireStatesN++;\n                return;\n            }\n\n            const straight = data[(m + dm + 1) + (n + dn + 1) * (width + 2)] & 1;\n            const left     = data[(m - dn + 1) + (n + dm + 1) * (width + 2)] & 1;\n            const right    = data[(m + dn + 1) + (n - dm + 1) * (width + 2)] & 1;\n\n            if (straight) {\n                // The line continues\n                if (left && right) {\n                    // Don't cross the streams!\n                    imageDecoderExtra[mnIdx >> 2] = imageDecoder[mnIdx]\n                    imageDecoder[mnIdx] = wireStatesN;\n                } else if (left) {\n                    incomingWires[incomingWiresN] = mnIdx;\n                    incomingWiresN++;\n                    incomingWireGroupsLen[wireStatesN]++;\n                } else if (right) {\n                    incomingWires[incomingWiresN] = mnIdx;\n                    incomingWiresN++;\n                    incomingWireGroupsLen[wireStatesN]++;\n                } else {\n                    wireActive |= data[(m + 1) + (n + 1) * (width + 2)] >> 1;\n                    imageDecoder[mnIdx] = wireStatesN;\n                }\n            } else if (left === right) {\n                // Impossibru!\n                throw 4;\n            } else {\n                wireActive |= data[(m + 1) + (n + 1) * (width + 2)] >> 1;\n                imageDecoder[mnIdx] = wireStatesN\n                if (left) {\n                    [dm, dn] = [-dn, +dm];\n                } else {\n                    [dm, dn] = [+dn, -dm];\n                }\n            }\n        }\n    }\n\n    for (let j = 0; j < height; j++) {\n        for (let i = 0; i < width; i++) {\n            if (!data[(i + 1) + (j + 1) * (width + 2)]) {\n                continue;\n            }\n            if (imageDecoder[i + j * width] != 0) {\n                continue;\n            }\n\n            traverseLoopsFrom(data, width, i, j);\n        }\n\n        if (j % 10 == 0) {\n            const fps = document.getElementById(\"fps\");\n            if (fps) { fps.innerHTML = j.toString(); }\n            await pause();\n        }\n    }\n\n    for (let i = 0; i < incomingWiresN; i++) {\n        incomingWires[i] = imageDecoder[incomingWires[i]];\n    }\n\n    let groupStart = 0;\n    for (let i = 0; i < wireStatesN; i++) {\n        let groupLength = incomingWireGroupsLen[i];\n\n        let incoming = incomingWires.slice(groupStart, groupStart + groupLength);\n        incoming.sort();\n        incomingWires.set(incoming, groupStart);\n\n        groupStart += groupLength;\n    }\n\n    // Round up to multiple of width so we can have less-skew textures.\n    const packedWireStatesN = ((wireStatesN >> 3) + 1023) & ~1023;\n    wireStatesN = (wireStatesN + 1023) & ~1023;\n    incomingWiresN = (incomingWiresN + 1023) & ~1023;\n\n    let packedWireStates = new Uint8Array(packedWireStatesN)\n    for (let i = 0; i < wireStatesN / 8; i++) {\n        for (let j = 0; j < 8; j++) {\n            packedWireStates[i] |= wireStates[i * 8 + j] << j;\n        }\n    }\n\n    return {\n        wireStates: packedWireStates,\n        incomingWires: incomingWires.slice(0, incomingWiresN),\n        incomingWireGroupsOff: incomingWireGroupsOff.slice(0, wireStatesN >> 3),\n        incomingWireGroupsLen: incomingWireGroupsLen.slice(0, wireStatesN),\n        imageDecoder: imageDecoder,\n        imageDecoderExtra: imageDecoderExtra\n    };\n}\n\nconst bootstrapInner = function(img) {\n    const width = img.naturalWidth;\n    const height = img.naturalHeight;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n\n    const context = canvas.getContext('2d');\n    if (!context) {\n        throw new Error(\"Canvas2D not supported\");\n    }\n\n    context.drawImage(img, 0, 0);\n    const pixels = context.getImageData(0, 0, width, height).data;\n\n    let numWires = 0;\n    const predecoded = new Uint8Array((width + 2) * (height + 2));\n    for (let j = 0; j < height; j++) {\n        for (let i = 0; i < width; i++) {\n            const kind = getKind(pixels, (i + (height - 1 - j) * width) * 4);\n            numWires += kind === 0 ? 0 : 1;\n            predecoded[(i + 1) + (j + 1) * (width + 2)] = kind;\n            predecoded[(i + 1) + (j + 1) * (width + 2)] = kind;\n        }\n    }\n\n    return [predecoded, width, height, numWires];\n}\n\nconst bootstrapFromImageTag = function(img) {\n    // Extract to allow collections of temporaries.\n    const [predecoded, width, height, numWires] = bootstrapInner(img);\n    return imageToGpuRepresentation(predecoded, width, height, numWires);\n}\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,QAAQ,GAAG,EAAE,CAAC;AACpB,MAAM,WAAW,GAAG,sBAAsB,CAAC;;;;;AAK3C,AAGC;;AAED,MAAM,aAAa,GAAG,SAAS,KAAK,EAAE;IAClC,IAAI,KAAK,CAAC,MAAM,KAAK,MAAM,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;QACvD,KAAK,CAAC,eAAe,EAAE,CAAC;QACxB,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;YACrB,IAAI,EAAE,GAAG,QAAQ,CAAC,KAAK,EAAE,CAAC;YAC1B,EAAE,EAAE,CAAC;SACR;KACJ;EACJ;;AAED,MAAM,CAAC,gBAAgB,CAAC,SAAS,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;;ACvBxD,OAAO;;;;"}